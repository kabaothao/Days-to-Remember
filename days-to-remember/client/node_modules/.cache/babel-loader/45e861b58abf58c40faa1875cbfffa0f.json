{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn } from \"./helpers.js\";\nvar specifierInfoCache = Object.create(null);\n\nfunction lookupSpecifierInfo(spec) {\n  var cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\n\nexport function keyFieldsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n    var extract = function (from, key) {\n      return context.readField(key, from);\n    };\n\n    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n      var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);\n\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n\n      __DEV__ ? invariant(extracted !== void 0, \"Missing field '\".concat(schemaKeyPath.join('.'), \"' while extracting keyFields from \").concat(JSON.stringify(object))) : invariant(extracted !== void 0, 2);\n      return extracted;\n    });\n    return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n  });\n}\nexport function keyArgsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n    var field = _a.field,\n        variables = _a.variables,\n        fieldName = _a.fieldName;\n    var collected = collectSpecifierPaths(specifier, function (keyPath) {\n      var firstKey = keyPath[0];\n      var firstChar = firstKey.charAt(0);\n\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          var directiveName_1 = firstKey.slice(1);\n          var d = field.directives.find(function (d) {\n            return d.name.value === directiveName_1;\n          });\n          var directiveArgs = d && argumentsObjectFromField(d, variables);\n          return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));\n        }\n\n        return;\n      }\n\n      if (firstChar === \"$\") {\n        var variableName = firstKey.slice(1);\n\n        if (variables && hasOwn.call(variables, variableName)) {\n          var varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n\n        return;\n      }\n\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    var suffix = JSON.stringify(collected);\n\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  var merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce(function (collected, path) {\n    var _a;\n\n    var toMerge = extractor(path);\n\n    if (toMerge !== void 0) {\n      for (var i = path.length - 1; i >= 0; --i) {\n        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n      }\n\n      collected = merger.merge(collected, toMerge);\n    }\n\n    return collected;\n  }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n  var info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    var paths_1 = info.paths = [];\n    var currentPath_1 = [];\n    spec.forEach(function (s, i) {\n      if (Array.isArray(s)) {\n        getSpecifierPaths(s).forEach(function (p) {\n          return paths_1.push(currentPath_1.concat(p));\n        });\n        currentPath_1.length = 0;\n      } else {\n        currentPath_1.push(s);\n\n        if (!Array.isArray(spec[i + 1])) {\n          paths_1.push(currentPath_1.slice(0));\n          currentPath_1.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths;\n}\n\nfunction extractKey(object, key) {\n  return object[key];\n}\n\nexport function extractKeyPath(object, path, extract) {\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return Array.isArray(obj) ? obj.map(function (child) {\n      return reducer(child, key);\n    }) : obj && extract(obj, key);\n  }, object));\n}\n\nfunction normalize(value) {\n  if (isNonNullObject(value)) {\n    if (Array.isArray(value)) {\n      return value.map(normalize);\n    }\n\n    return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n      return extractKeyPath(value, path);\n    });\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/key-extractor.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from \"../../utilities/globals\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities\";\n\nimport { hasOwn } from \"./helpers\";\nimport {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<string, {\n  paths?: string[][];\n  keyFieldsFn?: KeyFieldsFunction;\n  keyArgsFn?: KeyArgsFunction;\n}> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null));\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return info.keyFieldsFn || (info.keyFieldsFn = (\n    object,\n    context,\n  ) => {\n    const extract: typeof extractKey =\n      (from, key) => context.readField(key, from);\n\n    const keyObject = context.keyObject = collectSpecifierPaths(\n      specifier,\n      schemaKeyPath => {\n        let extracted = extractKeyPath(\n          context.storeObject,\n          schemaKeyPath,\n          // Using context.readField to extract paths from context.storeObject\n          // allows the extraction to see through Reference objects and respect\n          // custom read functions.\n          extract,\n        );\n\n        if (\n          extracted === void 0 &&\n          object !== context.storeObject &&\n          hasOwn.call(object, schemaKeyPath[0])\n        ) {\n          // If context.storeObject fails to provide a value for the requested\n          // path, fall back to the raw result object, if it has a top-level key\n          // matching the first key in the path (schemaKeyPath[0]). This allows\n          // key fields included in the written data to be saved in the cache\n          // even if they are not selected explicitly in context.selectionSet.\n          // Not being mentioned by context.selectionSet is convenient here,\n          // since it means these extra fields cannot be affected by field\n          // aliasing, which is why we can use extractKey instead of\n          // context.readField for this extraction.\n          extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n        }\n\n        invariant(\n          extracted !== void 0,\n          `Missing field '${schemaKeyPath.join('.')}' while extracting keyFields from ${\n            JSON.stringify(object)\n          }`,\n        );\n\n        return extracted;\n      },\n    );\n\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  });\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier: KeySpecifier): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return info.keyArgsFn || (info.keyArgsFn = (args, {\n    field,\n    variables,\n    fieldName,\n  }) => {\n    const collected = collectSpecifierPaths(specifier, keyPath => {\n      const firstKey = keyPath[0];\n      const firstChar = firstKey.charAt(0);\n\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          const directiveName = firstKey.slice(1);\n          // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n          const d = field.directives.find(d => d.name.value === directiveName);\n          // Fortunately argumentsObjectFromField works for DirectiveNode!\n          const directiveArgs = d && argumentsObjectFromField(d, variables);\n          // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n          return directiveArgs && extractKeyPath(\n            directiveArgs,\n            // If keyPath.length === 1, this code calls extractKeyPath with an\n            // empty path, which works because it uses directiveArgs as the\n            // extracted value.\n            keyPath.slice(1),\n          );\n        }\n        // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n        return;\n      }\n\n      if (firstChar === \"$\") {\n        const variableName = firstKey.slice(1);\n        if (variables && hasOwn.call(variables, variableName)) {\n          const varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n        // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n        return;\n      }\n\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n\n    const suffix = JSON.stringify(collected);\n\n    // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n\n    return fieldName;\n  });\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any,\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger;\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = info.paths = [];\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (Array.isArray(s)) {\n        getSpecifierPaths(s).forEach(p => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!Array.isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<\n  TObj extends Record<string, any>,\n  TKey extends string,\n>(object: TObj, key: TKey): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey,\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key): any {\n    return Array.isArray(obj)\n      ? obj.map(child => reducer(child, key))\n      : obj && extract!(obj, key);\n  }, object));\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (Array.isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(\n      Object.keys(value).sort(),\n      path => extractKeyPath(value, path),\n    ) as T;\n  }\n  return value;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}