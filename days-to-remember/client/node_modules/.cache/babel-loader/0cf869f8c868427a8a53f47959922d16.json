{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useQuery(query, options) {\n  var _a;\n\n  var context = useContext(getApolloContext());\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  verifyDocumentType(query, DocumentType.Query);\n\n  var _b = useState(function () {\n    var watchQueryOptions = createWatchQueryOptions(query, options);\n    var obsQuery = null;\n\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      obsQuery = client.watchQuery(watchQueryOptions);\n\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n      }\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery.getCurrentResult().loading) {\n      context.renderPromises.addQueryPromise({\n        getOptions: function () {\n          return createWatchQueryOptions(query, options);\n        },\n        fetchData: function () {\n          return new Promise(function (resolve) {\n            var sub = obsQuery.subscribe({\n              next: function (result) {\n                if (!result.loading) {\n                  resolve();\n                  sub.unsubscribe();\n                }\n              },\n              error: function () {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete: function () {\n                resolve();\n              }\n            });\n          });\n        }\n      }, function () {\n        return null;\n      });\n    }\n\n    return obsQuery;\n  }),\n      obsQuery = _b[0],\n      setObsQuery = _b[1];\n\n  var _c = useState(function () {\n    var _a, _b;\n\n    var result = obsQuery.getCurrentResult();\n\n    if (!result.loading && options) {\n      if (result.error) {\n        (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n      } else if (result.data) {\n        (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n      }\n    }\n\n    return result;\n  }),\n      result = _c[0],\n      setResult = _c[1];\n\n  var ref = useRef({\n    client: client,\n    query: query,\n    options: options,\n    result: result,\n    previousData: void 0,\n    watchQueryOptions: createWatchQueryOptions(query, options)\n  });\n  useEffect(function () {\n    var _a, _b;\n\n    var watchQueryOptions = createWatchQueryOptions(query, options);\n    var nextResult;\n\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      var obsQuery_1 = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery_1);\n      nextResult = obsQuery_1.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(function () {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      var previousResult = ref.current.result;\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n\n      if (!nextResult.loading && options) {\n        if (!result.loading) {\n          if (result.error) {\n            (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n          } else if (result.data) {\n            (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n          }\n        }\n      }\n    }\n\n    Object.assign(ref.current, {\n      client: client,\n      query: query,\n      options: options\n    });\n  }, [obsQuery, client, query, options]);\n  useEffect(function () {\n    if (context.renderPromises) {\n      return;\n    }\n\n    var subscription = obsQuery.subscribe(onNext, onError);\n\n    function onNext() {\n      var _a, _b;\n\n      var previousResult = ref.current.result;\n      var result = obsQuery.getCurrentResult();\n\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n\n      if (!result.loading) {\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n      }\n    }\n\n    function onError(error) {\n      var _a, _b;\n\n      var last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        throw error;\n      }\n\n      var previousResult = ref.current.result;\n\n      if (previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: NetworkStatus.error\n        });\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n      }\n    }\n\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n  var partial;\n  _a = result, partial = _a.partial, result = __rest(_a, [\"partial\"]);\n  {\n    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== 'cache-only') {\n      result = __assign(__assign({}, result), {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      obsQuery.refetch();\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(function () {});\n    }\n  }\n\n  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n    result = ref.current.result = {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    };\n  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n    result = {\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    result = __assign(__assign({}, result), {\n      error: result.error || new ApolloError({\n        graphQLErrors: result.errors\n      })\n    });\n  }\n\n  var obsQueryFields = useMemo(function () {\n    return {\n      refetch: obsQuery.refetch.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n    };\n  }, [obsQuery]);\n  return __assign(__assign(__assign({}, obsQueryFields), {\n    variables: obsQuery.variables,\n    client: client,\n    called: true,\n    previousData: ref.current.previousData\n  }), result);\n}\n\nfunction createWatchQueryOptions(query, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var skip = options.skip,\n      ssr = options.ssr,\n      onCompleted = options.onCompleted,\n      onError = options.onError,\n      displayName = options.displayName,\n      watchQueryOptions = __rest(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  return __assign({\n    query: query\n  }, watchQueryOptions);\n}","map":{"version":3,"sources":["../../../src/react/hooks/useQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (!result.loading) {\n          if (result.error) {\n            options.onError?.(result.error);\n          } else if (result.data) {\n            options.onCompleted?.(result.data);\n          }\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query, options });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(() => {});\n    }\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: obsQuery.variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...watchQueryOptions\n  } = options;\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  return { query, ...watchQueryOptions };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}